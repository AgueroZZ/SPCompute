y <- beta0 + betaG * G + betaE1 * E1 + betaE2 * E2 + stats::rlogis(n)
y <- ifelse(y > 0, 1, 0)
correct[i] <- summary(glm(y~G + E1 + E2, family = binomial("logit")))$coefficients[2,4] <= alpha
}
Power <- sum(correct)/B
}
else if(mode == "dominant"){
preva <- parameters$preva
pG <- 2*parameters$pG*(1-parameters$pG) + parameters$pG^2
qG <- 1 - pG
gammaG1 <- parameters$gammaG[1]
muE1 <- parameters$muE[1]
sigmaE1 <- parameters$sigmaE[1]
betaE1 <- parameters$betaE[1]
gammaG2 <- parameters$gammaG[2]
muE2 <- parameters$muE[2]
sigmaE2 <- parameters$sigmaE[2]
betaE2 <- parameters$betaE[2]
gamma01 <- muE1 - gammaG1 * (pG)
gamma02 <- muE2 - gammaG2 * (pG)
betaG <- parameters$betaG
if((sigmaE1^2) <= (gammaG1^2) * varG){return(message("Error: SigmaE must be larger to be compatible with other parameters"))}
if((sigmaE2^2) <= (gammaG2^2) * varG){return(message("Error: SigmaE must be larger to be compatible with other parameters"))}
sigmaError1 <- sqrt(sigmaE1^2 - (gammaG1^2) * varG)
sigmaError2 <- sqrt(sigmaE2^2 - (gammaG2^2) * varG)
solveForbeta0_dom_con <- function(preva, betaG, betaE1, betaE2, pG, gammaG1, gammaG2){
qG <- 1 - pG
ComputeP <- function(beta0){
set.seed(seed)
G <- sample(c(0,1), size = B, replace = TRUE, prob = c(qG,pG))
E1 <- gamma01 + gammaG1 * G + stats::rnorm(B, sd = sigmaError1)
E2 <- gamma02 + gammaG2 * G + stats::rnorm(B, sd = sigmaError2)
y <- beta0 + betaG * G + betaE1 * E1 + betaE2 * E2 + stats::rlogis(B)
P <- mean(ifelse(y > 0, 1, 0))
P - preva
}
stats::uniroot(ComputeP, c(-searchSizeBeta0, searchSizeBeta0))$root
}
beta0 <- solveForbeta0_dom_con(preva, betaG, betaE1, betaE2, pG, gammaG1, gammaG2)
set.seed(seed)
correct <- c()
for (i in 1:B) {
G <- sample(c(0,1), size = n, replace = TRUE, prob = c(qG, pG))
E1 <- gamma01 + gammaG1*G + stats::rnorm(n,sd = sigmaError1)
E2 <- gamma02 + gammaG2*G + stats::rnorm(n,sd = sigmaError2)
y <- beta0 + betaG * G + betaE1 * E1 + betaE2 * E2 + stats::rlogis(n)
y <- ifelse(y > 0, 1, 0)
correct[i] <- summary(glm(y~G + E1 + E2, family = binomial("logit")))$coefficients[2,4] <= alpha
}
Power <- sum(correct)/B
}
else if(mode == "recessive") {
preva <- parameters$preva
gammaG1 <- parameters$gammaG[1]
muE1 <- parameters$muE[1]
sigmaE1 <- parameters$sigmaE[1]
betaE1 <- parameters$betaE[1]
gammaG2 <- parameters$gammaG[2]
muE2 <- parameters$muE[2]
sigmaE2 <- parameters$sigmaE[2]
betaE2 <- parameters$betaE[2]
pG <- parameters$pG^2
qG <- 1 - pG
gamma01 <- muE1 - gammaG1 * (pG)
gamma02 <- muE2 - gammaG2 * (pG)
betaG <- parameters$betaG
if((sigmaE1^2) <= (gammaG1^2) * qG*pG){return(message("Error: SigmaE[1] must be larger to be compatible with other parameters"))}
sigmaError1 <- sqrt(sigmaE1^2 - (gammaG1^2) * qG*pG)
if((sigmaE2^2) <= (gammaG2^2) * qG*pG){return(message("Error: SigmaE[2] must be larger to be compatible with other parameters"))}
sigmaError2 <- sqrt(sigmaE2^2 - (gammaG2^2) * qG*pG)
solveForbeta0_rec_con <- function(preva, betaG, betaE1, betaE2, pG, gammaG1, gammaG2){
qG <- 1 - pG
ComputeP <- function(beta0){
set.seed(seed)
G <- sample(c(0,1), size = B, replace = TRUE, prob = c(qG,pG))
E1 <- gamma01 + gammaG1 * G + stats::rnorm(B, sd = sigmaError1)
E2 <- gamma02 + gammaG2 * G + stats::rnorm(B, sd = sigmaError2)
y <- beta0 + betaG * G + betaE1 * E1 + betaE2 * E2 + stats::rlogis(B)
P <- mean(ifelse(y > 0, 1, 0))
P - preva
}
stats::uniroot(ComputeP, c(-searchSizeBeta0, searchSizeBeta0))$root
}
beta0 <- solveForbeta0_rec_con(preva, betaG, betaE1, betaE2, pG, gammaG1, gammaG2)
set.seed(seed)
correct <- c()
for (i in 1:B) {
G <- sample(c(0,1), size = n, replace = TRUE, prob = c(qG, pG))
E1 <- gamma01 + gammaG1*G + stats::rnorm(n,sd = sigmaError1)
E2 <- gamma02 + gammaG2*G + stats::rnorm(n,sd = sigmaError2)
y <- beta0 + betaG * G + betaE1 * E1 + betaE2 * E2 + stats::rlogis(n)
y <- ifelse(y > 0, 1, 0)
correct[i] <- summary(glm(y~G + E1 + E2, family = binomial("logit")))$coefficients[2,4] <= alpha
}
Power <- sum(correct)/B
}
Power
}
Compute_Power_Sim_BCC(n = 2000, B = 10000,
parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9,0.5), gammaG = c(0.2,0.1), muE = c(0,0.1), sigmaE = c(1,2), pG = 0.3),
mode = "recessive")
Compute_Power_Emp_BCC(n = 2000, B = 1000,
parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9,0.5), gammaG = c(0.2,0.1), muE = c(0,0.1), sigmaE = c(1,2), pG = 0.3),
mode = "recessive")
Compute_Power_Sim_BCC(n = 2000, B = 10000,
parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9,0.5), gammaG = c(0.2,0.1), muE = c(0,0.1), sigmaE = c(1,2), pG = 0.3),
mode = "recessive")
Compute_Power_Emp_BCC(n = 2000, B = 2000,
parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9,0.5), gammaG = c(0.2,0.1), muE = c(0,0.1), sigmaE = c(1,2), pG = 0.3),
mode = "recessive")
Compute_Power_Emp_BCC(n = 2000, B = 5000,
parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9,0.5), gammaG = c(0.2,0.1), muE = c(0,0.1), sigmaE = c(1,2), pG = 0.3),
mode = "recessive")
Compute_Power_Sim_BCC(n = 2000, B = 10000,
parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9,0.5), gammaG = c(0.2,0.1), muE = c(0,0.1), sigmaE = c(1,2), pG = 0.3),
mode = "dominant")
Compute_Power_Sim_BCC(n = 1000, B = 10000,
parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9,0.5), gammaG = c(0.2,0.1), muE = c(0,0.1), sigmaE = c(1,2), pG = 0.3),
mode = "dominant")
Compute_Power_Emp_BCC(n = 1000, B = 1000,
parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9,0.5), gammaG = c(0.2,0.1), muE = c(0,0.1), sigmaE = c(1,2), pG = 0.3),
mode = "dominant")
Compute_Power_Emp_BCC <- function(n, B = 10000, parameters, mode = "additive", alpha = 0.05, seed = 123, searchSizeBeta0 = 8){
if(mode == "additive"){
preva <- parameters$preva
pG <- parameters$pG
qG <- 1 - pG
gammaG1 <- parameters$gammaG[1]
muE1 <- parameters$muE[1]
sigmaE1 <- parameters$sigmaE[1]
betaE1 <- parameters$betaE[1]
gammaG2 <- parameters$gammaG[2]
muE2 <- parameters$muE[2]
sigmaE2 <- parameters$sigmaE[2]
betaE2 <- parameters$betaE[2]
gamma01 <- muE1 - gammaG1 * (2*pG*qG + 2*pG^2)
gamma02 <- muE2 - gammaG2 * (2*pG*qG + 2*pG^2)
betaG <- parameters$betaG
varG <- (2*pG*qG + 4*pG^2) - (2*pG*qG + 2*pG^2)^2
if((sigmaE1^2) <= (gammaG1^2) * varG){return(message("Error: SigmaE[1] must be larger to be compatible with other parameters"))}
if((sigmaE2^2) <= (gammaG2^2) * varG){return(message("Error: SigmaE[2] must be larger to be compatible with other parameters"))}
sigmaError1 <- sqrt(sigmaE1^2 - (gammaG1^2) * varG)
sigmaError2 <- sqrt(sigmaE2^2 - (gammaG2^2) * varG)
solveForbeta0_add_con <- function(preva, betaG, betaE1, betaE2, pG, gammaG1, gammaG2){
qG <- 1 - pG
ComputeP <- function(beta0){
set.seed(seed)
G <- sample(c(0,1,2), size = B, replace = TRUE, prob = c(qG^2, 2*pG*qG, pG^2))
E1 <- gamma01 + gammaG1 * G + stats::rnorm(B, sd = sigmaError1)
E2 <- gamma02 + gammaG2 * G + stats::rnorm(B, sd = sigmaError2)
y <- beta0 + betaG * G + betaE1 * E1 + betaE2 * E2 + stats::rlogis(B)
P <- mean(ifelse(y > 0, 1, 0))
P - preva
}
stats::uniroot(ComputeP, c(-searchSizeBeta0, searchSizeBeta0))$root
}
beta0 <- solveForbeta0_add_con(preva, betaG, betaE1, betaE2, pG, gammaG1, gammaG2)
set.seed(seed)
correct <- c()
for (i in 1:B) {
G <- sample(c(0,1,2), size = n, replace = TRUE, prob = c(qG^2,2*pG*qG, pG^2))
E1 <- gamma01 + gammaG1*G + stats::rnorm(n,sd = sigmaError1)
E2 <- gamma02 + gammaG2*G + stats::rnorm(n,sd = sigmaError2)
y <- beta0 + betaG * G + betaE1 * E1 + betaE2 * E2 + stats::rlogis(n)
y <- ifelse(y > 0, 1, 0)
correct[i] <- summary(glm(y~G + E1 + E2, family = binomial("logit")))$coefficients[2,4] <= alpha
}
Power <- sum(correct)/B
}
else if(mode == "dominant"){
preva <- parameters$preva
pG <- 2*parameters$pG*(1-parameters$pG) + parameters$pG^2
qG <- 1 - pG
gammaG1 <- parameters$gammaG[1]
muE1 <- parameters$muE[1]
sigmaE1 <- parameters$sigmaE[1]
betaE1 <- parameters$betaE[1]
gammaG2 <- parameters$gammaG[2]
muE2 <- parameters$muE[2]
sigmaE2 <- parameters$sigmaE[2]
betaE2 <- parameters$betaE[2]
gamma01 <- muE1 - gammaG1 * (pG)
gamma02 <- muE2 - gammaG2 * (pG)
betaG <- parameters$betaG
varG <- qG*pG
if((sigmaE1^2) <= (gammaG1^2) * varG){return(message("Error: SigmaE must be larger to be compatible with other parameters"))}
if((sigmaE2^2) <= (gammaG2^2) * varG){return(message("Error: SigmaE must be larger to be compatible with other parameters"))}
sigmaError1 <- sqrt(sigmaE1^2 - (gammaG1^2) * varG)
sigmaError2 <- sqrt(sigmaE2^2 - (gammaG2^2) * varG)
solveForbeta0_dom_con <- function(preva, betaG, betaE1, betaE2, pG, gammaG1, gammaG2){
qG <- 1 - pG
ComputeP <- function(beta0){
set.seed(seed)
G <- sample(c(0,1), size = B, replace = TRUE, prob = c(qG,pG))
E1 <- gamma01 + gammaG1 * G + stats::rnorm(B, sd = sigmaError1)
E2 <- gamma02 + gammaG2 * G + stats::rnorm(B, sd = sigmaError2)
y <- beta0 + betaG * G + betaE1 * E1 + betaE2 * E2 + stats::rlogis(B)
P <- mean(ifelse(y > 0, 1, 0))
P - preva
}
stats::uniroot(ComputeP, c(-searchSizeBeta0, searchSizeBeta0))$root
}
beta0 <- solveForbeta0_dom_con(preva, betaG, betaE1, betaE2, pG, gammaG1, gammaG2)
set.seed(seed)
correct <- c()
for (i in 1:B) {
G <- sample(c(0,1), size = n, replace = TRUE, prob = c(qG, pG))
E1 <- gamma01 + gammaG1*G + stats::rnorm(n,sd = sigmaError1)
E2 <- gamma02 + gammaG2*G + stats::rnorm(n,sd = sigmaError2)
y <- beta0 + betaG * G + betaE1 * E1 + betaE2 * E2 + stats::rlogis(n)
y <- ifelse(y > 0, 1, 0)
correct[i] <- summary(glm(y~G + E1 + E2, family = binomial("logit")))$coefficients[2,4] <= alpha
}
Power <- sum(correct)/B
}
else if(mode == "recessive") {
preva <- parameters$preva
gammaG1 <- parameters$gammaG[1]
muE1 <- parameters$muE[1]
sigmaE1 <- parameters$sigmaE[1]
betaE1 <- parameters$betaE[1]
gammaG2 <- parameters$gammaG[2]
muE2 <- parameters$muE[2]
sigmaE2 <- parameters$sigmaE[2]
betaE2 <- parameters$betaE[2]
pG <- parameters$pG^2
qG <- 1 - pG
gamma01 <- muE1 - gammaG1 * (pG)
gamma02 <- muE2 - gammaG2 * (pG)
betaG <- parameters$betaG
if((sigmaE1^2) <= (gammaG1^2) * qG*pG){return(message("Error: SigmaE[1] must be larger to be compatible with other parameters"))}
sigmaError1 <- sqrt(sigmaE1^2 - (gammaG1^2) * qG*pG)
if((sigmaE2^2) <= (gammaG2^2) * qG*pG){return(message("Error: SigmaE[2] must be larger to be compatible with other parameters"))}
sigmaError2 <- sqrt(sigmaE2^2 - (gammaG2^2) * qG*pG)
solveForbeta0_rec_con <- function(preva, betaG, betaE1, betaE2, pG, gammaG1, gammaG2){
qG <- 1 - pG
ComputeP <- function(beta0){
set.seed(seed)
G <- sample(c(0,1), size = B, replace = TRUE, prob = c(qG,pG))
E1 <- gamma01 + gammaG1 * G + stats::rnorm(B, sd = sigmaError1)
E2 <- gamma02 + gammaG2 * G + stats::rnorm(B, sd = sigmaError2)
y <- beta0 + betaG * G + betaE1 * E1 + betaE2 * E2 + stats::rlogis(B)
P <- mean(ifelse(y > 0, 1, 0))
P - preva
}
stats::uniroot(ComputeP, c(-searchSizeBeta0, searchSizeBeta0))$root
}
beta0 <- solveForbeta0_rec_con(preva, betaG, betaE1, betaE2, pG, gammaG1, gammaG2)
set.seed(seed)
correct <- c()
for (i in 1:B) {
G <- sample(c(0,1), size = n, replace = TRUE, prob = c(qG, pG))
E1 <- gamma01 + gammaG1*G + stats::rnorm(n,sd = sigmaError1)
E2 <- gamma02 + gammaG2*G + stats::rnorm(n,sd = sigmaError2)
y <- beta0 + betaG * G + betaE1 * E1 + betaE2 * E2 + stats::rlogis(n)
y <- ifelse(y > 0, 1, 0)
correct[i] <- summary(glm(y~G + E1 + E2, family = binomial("logit")))$coefficients[2,4] <= alpha
}
Power <- sum(correct)/B
}
Power
}
Compute_Power_Sim_BCC(n = 1000, B = 10000,
parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9,0.5), gammaG = c(0.2,0.1), muE = c(0,0.1), sigmaE = c(1,2), pG = 0.3),
mode = "dominant")
Compute_Power_Emp_BCC(n = 1000, B = 1000,
parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9,0.5), gammaG = c(0.2,0.1), muE = c(0,0.1), sigmaE = c(1,2), pG = 0.3),
mode = "dominant")
Compute_Power_Sim_BCC(n = 500, B = 10000,
parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9,0.5), gammaG = c(0.2,0.1), muE = c(0,0.1), sigmaE = c(1,2), pG = 0.3),
mode = "additive")
Compute_Power_Emp_BCC(n = 500, B = 1000,
parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9,0.5), gammaG = c(0.2,0.1), muE = c(0,0.1), sigmaE = c(1,2), pG = 0.3),
mode = "additive")
source("D:/ZZA/SPCompute/R/01_single_E.R")
convert_preva_to_intercept(parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9), gammaG = c(0.2), muE = c(0), sigmaE = c(1), pG = 0.3))
convert_preva_to_intercept <- function(parameters, mode = "additive", covariate = "binary", seed = 123, B = 10000, searchSizeBeta0 = 8, searchSizeGamma0 = 8){
check_parameters(parameters = parameters, response = "binary", covariate = covariate)
preva <- parameters$preva
betaG <- parameters$betaG
if(covariate == "binary"){
ComputeEgivenG <- function(gamma0,gammaG,G, E = 1){
PEG <- (exp(gamma0 + gammaG * G)^E)/(1+exp(gamma0 + gammaG * G))
PEG
}
ComputeYgivenGE <- function(beta0,betaG, betaE, G, E, Y = 1){
PYGE <- (exp(beta0 + betaG * G + betaE * E)^Y)/(1 + exp(beta0 + betaG * G + betaE * E))
PYGE
}
pG <- parameters$pG
pE <- parameters$pE
betaE <- parameters$betaE
gammaG <- parameters$gammaG
if(mode == "recessive"){
pG <- pG^2
qG <- 1- pG
### Solve for gamma0
solveForgamma0 <- function(pE,gammaG, pG){
qG <- 1 - pG
ComputePE <- function(gamma0){
PE <- ComputeEgivenG(gamma0,gammaG,G = 0) * (qG) +
ComputeEgivenG(gamma0,gammaG,G = 1) * (pG)
PE - pE
}
uniroot(ComputePE, c(-searchSizeGamma0, searchSizeGamma0), tol = (.Machine$double.eps^0.5) )$root
}
### Solve for beta0
solveForbeta0 <- function(preva, betaG, betaE, pG, pE, gammaG){
qG <- 1 - pG
gamma0 <- solveForgamma0(pE,gammaG, pG)
ComputeP <- function(beta0){
P <- ComputeYgivenGE(beta0,betaG, betaE, G = 0, E = 1, Y = 1) * ComputeEgivenG(gamma0,gammaG,G = 0) * (qG) + ComputeYgivenGE(beta0,betaG, betaE, G = 0, E = 0, Y = 1) * (1 - ComputeEgivenG(gamma0,gammaG,G = 0)) * (qG) +
ComputeYgivenGE(beta0,betaG, betaE, G = 1, E = 1, Y = 1) * ComputeEgivenG(gamma0,gammaG,G = 1) * (pG) + ComputeYgivenGE(beta0,betaG, betaE, G = 1, E = 0, Y = 1) * (1 - ComputeEgivenG(gamma0,gammaG,G = 1)) * (pG)
P - preva
}
uniroot(ComputeP, c(-searchSizeBeta0, searchSizeBeta0), tol = (.Machine$double.eps^0.5) )$root
}
gamma0 <- solveForgamma0(pE,gammaG, pG)
beta0 <- solveForbeta0(preva, betaG, betaE, pG, pE, gammaG)
return(list(gamma0 = gamma0, beta0 = beta0))
}
else if(mode == "dominant"){
qG <- (1-pG)^2
pG <- 1 - qG
### Solve for gamma0
solveForgamma0 <- function(pE,gammaG, pG){
qG <- 1 - pG
ComputePE <- function(gamma0){
PE <- ComputeEgivenG(gamma0,gammaG,G = 0) * (qG) +
ComputeEgivenG(gamma0,gammaG,G = 1) * (pG)
PE - pE
}
uniroot(ComputePE, c(-searchSizeGamma0, searchSizeGamma0), tol = (.Machine$double.eps^0.5) )$root
}
### Solve for beta0
solveForbeta0 <- function(preva, betaG, betaE, pG, pE, gammaG){
qG <- 1 - pG
gamma0 <- solveForgamma0(pE,gammaG, pG)
ComputeP <- function(beta0){
P <- ComputeYgivenGE(beta0,betaG, betaE, G = 0, E = 1, Y = 1) * ComputeEgivenG(gamma0,gammaG,G = 0) * (qG) + ComputeYgivenGE(beta0,betaG, betaE, G = 0, E = 0, Y = 1) * (1 - ComputeEgivenG(gamma0,gammaG,G = 0)) * (qG) +
ComputeYgivenGE(beta0,betaG, betaE, G = 1, E = 1, Y = 1) * ComputeEgivenG(gamma0,gammaG,G = 1) * (pG) + ComputeYgivenGE(beta0,betaG, betaE, G = 1, E = 0, Y = 1) * (1 - ComputeEgivenG(gamma0,gammaG,G = 1)) * (pG)
P - preva
}
uniroot(ComputeP, c(-searchSizeBeta0, searchSizeBeta0), tol = (.Machine$double.eps^0.5) )$root
}
gamma0 <- solveForgamma0(pE,gammaG, pG)
beta0 <- solveForbeta0(preva, betaG, betaE, pG, pE, gammaG)
return(list(gamma0 = gamma0, beta0 = beta0))
}
else{
solveForgamma0 <- function(pE,gammaG, pG){
qG <- 1 - pG
ComputePE <- function(gamma0){
PE <- ComputeEgivenG(gamma0,gammaG,G = 0) * (qG^2) + ComputeEgivenG(gamma0,gammaG,G = 2) * (pG^2) +
ComputeEgivenG(gamma0,gammaG,G = 1) * (2*qG*pG)
PE - pE
}
uniroot(ComputePE, c(-searchSizeGamma0, searchSizeGamma0), tol = (.Machine$double.eps^0.5) )$root
}
### Solve for beta0
solveForbeta0 <- function(preva, betaG, betaE, pG, pE, gammaG){
qG <- 1 - pG
gamma0 <- solveForgamma0(pE,gammaG, pG)
ComputeP <- function(beta0){
P <- ComputeYgivenGE(beta0,betaG, betaE, G = 0, E = 1, Y = 1) * ComputeEgivenG(gamma0,gammaG,G = 0) * (qG^2) + ComputeYgivenGE(beta0,betaG, betaE, G = 0, E = 0, Y = 1) * (1 - ComputeEgivenG(gamma0,gammaG,G = 0)) * (qG^2) +
ComputeYgivenGE(beta0,betaG, betaE, G = 1, E = 1, Y = 1) * ComputeEgivenG(gamma0,gammaG,G = 1) * (2* pG * qG) + ComputeYgivenGE(beta0,betaG, betaE, G = 1, E = 0, Y = 1) * (1 - ComputeEgivenG(gamma0,gammaG,G = 1)) * (2* pG * qG) +
ComputeYgivenGE(beta0,betaG, betaE, G = 2, E = 1, Y = 1) * ComputeEgivenG(gamma0,gammaG,G = 2) * (pG^2) + ComputeYgivenGE(beta0,betaG, betaE, G = 2, E = 0, Y = 1) * (1 - ComputeEgivenG(gamma0, gammaG, G = 2)) * (pG^2)
P - preva
}
uniroot(ComputeP, c(-searchSizeBeta0, searchSizeBeta0), tol = (.Machine$double.eps^0.5) )$root
}
gamma0 <- solveForgamma0(pE,gammaG, pG)
beta0 <- solveForbeta0(preva, betaG, betaE, pG, pE, gammaG)
return(list(gamma0 = gamma0, beta0 = beta0))
}
}
else if(covariate == "continuous"){
pG <- parameters$pG
qG <- 1 - pG
muE <- parameters$muE
sigmaE <- parameters$sigmaE
betaE <- parameters$betaE
gammaG <- parameters$gammaG
if(mode == "additive"){
gamma0 <- muE - gammaG * (2*pG*qG + 2*pG^2)
betaG <- parameters$betaG
betaE <- parameters$betaE
varG <- (2*pG*qG + 4*pG^2) - (2*pG*qG + 2*pG^2)^2
if((sigmaE^2) <= (gammaG^2) * varG){return(message("Error: SigmaE must be larger to be compatible with other parameters"))}
sigmaError <- sqrt(sigmaE^2 - (gammaG^2) * varG)
solveForbeta0 <- function(preva, betaG, betaE, pG, gammaG){
qG <- 1 - pG
ComputeP <- function(beta0){
set.seed(seed)
G <- sample(c(0,1,2), size = B, replace = T, prob = c(qG^2, 2*pG*qG, pG^2))
E <- gamma0 + gammaG * G + rnorm(B, sd = sigmaError)
y <- beta0 + betaG * G + betaE * E + rlogis(B)
P <- mean(ifelse(y > 0, 1, 0))
P - preva
}
uniroot(ComputeP, c(-searchSizeBeta0, searchSizeBeta0), tol = (.Machine$double.eps^0.5) )$root
}
beta0 <- solveForbeta0(preva, betaG, betaE, pG, gammaG)
return(list(gamma0 = gamma0, sigmaError = sigmaError, beta0 = beta0))
}
else if(mode == "dominant"){
pG <- 2*parameters$pG*(1-parameters$pG) + parameters$pG^2
qG <- 1 - pG
gammaG <- parameters$gammaG
muE <- parameters$muE
sigmaE <- parameters$sigmaE
gamma0 <- muE - gammaG * (pG)
betaG <- parameters$betaG
betaE <- parameters$betaE
varG <- pG*qG
if((sigmaE^2) <= (gammaG^2) * varG){return(message("Error: SigmaE must be larger to be compatible with other parameters"))}
sigmaError <- sqrt(sigmaE^2 - (gammaG^2) * varG)
solveForbeta0 <- function(preva, betaG, betaE, pG, gammaG){
qG <- 1 - pG
ComputeP <- function(beta0){
set.seed(seed)
G <- sample(c(0,1), size = B, replace = T, prob = c(qG,pG))
E <- gamma0 + gammaG * G + rnorm(B, sd = sigmaError)
y <- beta0 + betaG * G + betaE * E + rlogis(B)
P <- mean(ifelse(y > 0, 1, 0))
P - preva
}
uniroot(ComputeP, c(-searchSizeBeta0, searchSizeBeta0), tol = (.Machine$double.eps^0.5) )$root
}
beta0 <- solveForbeta0(preva, betaG, betaE, pG, gammaG)
return(list(gamma0 = gamma0, sigmaError = sigmaError, beta0 = beta0))
}
else{
pG <- parameters$pG^2
qG <- 1 - pG
gammaG <- parameters$gammaG
muE <- parameters$muE
sigmaE <- parameters$sigmaE
gamma0 <- muE - gammaG * (pG)
betaG <- parameters$betaG
betaE <- parameters$betaE
varG <- pG*qG
if((sigmaE^2) <= (gammaG^2) * varG){return(message("Error: SigmaE must be larger to be compatible with other parameters"))}
sigmaError <- sqrt(sigmaE^2 - (gammaG^2) * varG)
solveForbeta0 <- function(preva, betaG, betaE, pG, gammaG){
qG <- 1 - pG
ComputeP <- function(beta0){
set.seed(seed)
G <- sample(c(0,1), size = B, replace = T, prob = c(qG,pG))
E <- gamma0 + gammaG * G + rnorm(B, sd = sigmaError)
y <- beta0 + betaG * G + betaE * E + rlogis(B)
P <- mean(ifelse(y > 0, 1, 0))
P - preva
}
uniroot(ComputeP, c(-searchSizeBeta0, searchSizeBeta0), tol = (.Machine$double.eps^0.5) )$root
}
beta0 <- solveForbeta0(preva, betaG, betaE, pG, gammaG)
return(list(gamma0 = gamma0, sigmaError = sigmaError, beta0 = beta0))
}
}
else{
ComputeYgivenG <- function(beta0,betaG, G, Y = 1){
PYG <- (exp(beta0 + betaG * G)^Y)/(1 + exp(beta0 + betaG * G))
PYG
}
if(mode == "dominant"){
solveForbeta0 <- function(preva, betaG, pG){
qG <- 1 - pG
ComputeP <- function(beta0){
P <- ComputeYgivenG(beta0,betaG, G = 0, Y = 1) * (qG) + ComputeYgivenG(beta0,betaG, G = 1, Y = 1) * (pG)
P - preva
}
uniroot(ComputeP, c(-searchSizeBeta0, searchSizeBeta0), tol = (.Machine$double.eps^0.5) )$root
}
pG <- (parameters$pG^2) + 2*((1-parameters$pG) * parameters$pG)
beta0 <- solveForbeta0(preva, betaG, pG)
return(beta0)
}
else if(mode == "additive"){
solveForbeta0 <- function(preva, betaG, pG){
qG <- 1 - pG
ComputeP <- function(beta0){
P <- ComputeYgivenG(beta0,betaG, G = 0, Y = 1) * (qG^2) + ComputeYgivenG(beta0,betaG, G = 2, Y = 1) * (pG^2) + ComputeYgivenG(beta0,betaG, G = 1, Y = 1) * (2*pG*qG)
P - preva
}
uniroot(ComputeP, c(-searchSizeBeta0, searchSizeBeta0), tol = (.Machine$double.eps^0.5) )$root
}
beta0 <- solveForbeta0(preva, betaG, parameters$pG)
return(beta0)
}
else{
solveForbeta0 <- function(preva, betaG, pG){
qG <- 1 - pG
ComputeP <- function(beta0){
P <- ComputeYgivenG(beta0,betaG, G = 0, Y = 1) * (qG) + ComputeYgivenG(beta0,betaG, G = 1, Y = 1) * (pG)
P - preva
}
uniroot(ComputeP, c(-searchSizeBeta0, searchSizeBeta0), tol = (.Machine$double.eps^0.5) )$root
}
pG <- (parameters$pG^2)
beta0 <- solveForbeta0(preva, betaG, pG)
return(beta0)
}
}
}
convert_preva_to_intercept(parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9), gammaG = c(0.2), muE = c(0), sigmaE = c(1), pG = 0.3))
convert_preva_to_intercept(parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9), gammaG = c(0.2), muE = c(0), sigmaE = c(1), pG = 0.3), covariate = "continuous")
convert_preva_to_intercept(parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9), gammaG = c(0.2), pE = 0.4, pG = 0.3))
convert_preva_to_intercept(parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9), gammaG = c(0.2), pE = 0.4, pG = 0.3), mode = "recessive")
convert_preva_to_intercept(parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9), gammaG = c(0.2), pE = 0.4, pG = 0.3), mode = "recessive", covariate = "none")
convert_preva_to_intercept(parameters = list(preva = 0.2, betaG = 0.6, betaE = c(0.9), gammaG = c(0.2), pE = 0.4, pG = 0.3), mode = "dominant", covariate = "none")
source("D:/ZZA/SPCompute/R/01_single_E.R")
